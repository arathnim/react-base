{"content":"<p>Earlier today, I took part in a conversation about the lack of scanf in racket.\nA case was mentioned where some unlucky soul was trying to parse comma-seperated square-bracket\nlists in racket, and realized that scanf would have served better.\nOne poster asked how something so important could be missing, and derided racket as &quot;an academic language.&quot;\nMany solutions were presented in the conversation, of varying levels of generality.</p>\n<p>Most of the solutions revolved around using regex and capture groups to bind the terms:</p>\n<pre><code>(regexp-group-read #rx&quot;\\\\[(.+), *(.+), *(.+)\\\\]&quot; &quot;[1, foo, 0.42]&quot;) =&gt; (1 foo 0.42)\n</code></pre><p>Some sought to combine scanf and regex in various ways:</p>\n<pre><code>(regexp-scan #rx&quot;\\\\[%d, %s, %f\\\\]&quot; &quot;[1, foo, 0.42]&quot;) =&gt; (1 foo 0.42)\n</code></pre><p>And some modified the reader to help parse the terms.\nEach was different, with their own drawbacks and strengths, an abstraction in their own right.\nThis process, considering what the optimal abstraction is, balancing speed and ease of implementation and ease\nof use, is the fun part of language design.</p>\n<p>In other languages, you only have what the language implementors think was good enough. You use the same\nabstraction over and over, and you lose the ability to concieve of other abstractions.\nEven if you&#39;re a learned programmer, and know of different abstractions in many languages, it doesn&#39;t mean you can create new ones.\nThat skill, like any other, is honed through practice, and while knowing of many abstractions certainly helps, only by creating new\nabstractions will you get better at it.</p>\n<p>While users of other languages see the lack of tools such as this in languages like racket as a point against them,\nlispers see a space full of possibilities, free to explore, free to create whatever abstractions we damn well please.\nFor those of you who haven&#39;t done it, this is truly exhilarating. The more general the abstraction, the better it feels.\nMore than that, it opens new realms of thought. The progression is astounding: it starts with writing macros to eliminate common\npatterns, and then you get above the clouds and start thinking of entirely new ways to destructure lists, parse strings,\nannotate, control state, and even abstractions to help metaprogramming.</p>\n<p>Lest I get too high up on my soapbox, I should note that this property is not exclusive to lisp, lisp is just well-suited\nto this task, because metaprogramming used with s-exprs is a convient way to implement many, many forms of abstraction.\nThis property is the thing that we, as language designers, should be optimizing for.</p>\n","data":{"title":"Racket and Abstraction","date":"November 5th, 2017"},"excerpt":""}