{"content":"<p>Destructuring, also called structural binding, is a method of binding symbols to a set of values,\nwidely used in the lisp family of languages, and in a few other popular languages.\nDestructuring is most commonly associated with lists, although it works on arrays, objects, and hash tables as well.\nEssentially, you give a pattern or a template with variables, and a set of values to match against that pattern,\nand your language binds those variables to the corresponding values.</p>\n<p>There are two kinds of destructuring, assignment destructuring,\nwhere you give a template where you would normally give a single variable to bind,\nand function destructuring, where the list of arguments to a function is destructured.</p>\n<p>Python and JS have assignment destructuring, using <code>=</code>, the normal assignment operator:</p>\n<pre><code class=\"lang-py\">(a, (b, (c, d))) = (1, (2, (3, 4)))\n# a = 1, b = 2, c = 3, d = 4\n</code></pre>\n<pre><code class=\"lang-js\">var a, b, rest;\n[a, b, ...rest] = [1, 2, 3, 4, 5];\n// a = 1, b = 2, rest = [3, 4, 5]\n</code></pre>\n<p>In this case, the pattern, or template, is on the left, and the set of values being bound on the right.</p>\n<p>The JS shows an example of a common pattern in destructuring, the <code>...</code> operator, which binds to anything remaining in the list.\nAfter all, destructuring would be pretty useless if we had to give names to every element of the list each time.\nThe same template would be written as <code>a b &amp;rest rest</code> in Common Lisp and <code>a b &amp; rest</code> in Clojure.</p>\n<p><a href=\"http://tony.pitluga.com/2011/08/08/destructuring-with-ruby.html\">Ruby</a> has an oddly named operator called &#39;splat&#39;(<code>*</code>), which either &#39;slurps&#39; or &#39;splits&#39;,\ndepending on which side of the assignment it happens to be on. (This explains why conversations between ruby people seem insane)</p>\n<p>Here&#39;s the splat operator slurping up the remaining list arguments:</p>\n<pre><code class=\"lang-rb\">a, b = [&quot;apple&quot;, &quot;banana&quot;]\n# a = &quot;apple&quot;, b = &quot;banana&quot;\n\na, b, *rest = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;durian&quot;, &quot;elderberry&quot;]\n# a = &quot;apple&quot;, b = &quot;banana&quot;, rest = [&quot;cherry&quot;, &quot;durian&quot;, &quot;elderberry&quot;]\n</code></pre>\n<pre><code class=\"lang-rb\"># this function takes any number of lists or elements,\n# and appends them all together\ndef append(*lists)\n  lists.flatten(1)\nend\n\nappend([2, 3, 4], [5, 6, 7], [8, 9, 10])\n# =&gt; [2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nappend(&quot;foo&quot;, [&quot;bar&quot;, &quot;baz&quot;], &quot;qux&quot;)\n# =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]\n</code></pre>\n<p>Note that the function signature of append has only the &#39;lists&#39; argument, which simply binds the list of provided arguments to &#39;lists&#39;.\nThere can be any number of provided arguments, including zero.</p>\n<p>By now, you&#39;re probably bored with binding symbols to lists of fruit and numbers, so let&#39;s talk about keyword arguments.\nThe first thing you need to know about keyword aguments is that keyword aguments are fantastic.\nI could write a whole blog post just about keyword arguments.</p>\n<p>Keywords are lightweight strings, which means that they&#39;re not used for holding text, but only for specifying things, like keys in a hash table.\nIn both Ruby and Lisp, keywords are preceded with a colon, and ended with a space, like this:</p>\n<pre><code class=\"lang-cl\">:keyword\n:also-a-keyword\n</code></pre>\n<p>Keyword arguments, also called named arguments, are a specific use of keywords in argument lists to specify values.</p>\n<pre><code class=\"lang-cl\">(draw-circle :x 300 :y 200 :radius 350)\n</code></pre>\n<p>They make functions much easier to read, at the expense of brevity.\nKeyword arguments are almost always optional, and can be given in any order.\nThey can also be used to &#39;collapse&#39; similarly named functions into a single function.\nYou may have seen some crypto API which looks similar to this:</p>\n<pre><code class=\"lang-py\"># &#39;[0] * 128&#39; is shorthand for a vector with 128 zero&#39;d elements\ncryptor = makeCryptor(&quot;AES&quot;, 128, &quot;CBC&quot;, &quot;secret key&quot;, [0] * 128)\ncryptor.encrypt(&quot;attack at dawn&quot;)\n</code></pre>\n<p>This is actually a pretty decent API, some are a lot worse. (<em>cough</em> CommonCrypto <em>cough</em> Bouncy Castle <em>cough</em>)\nYou&#39;ll also see it with objects for the various ciphers and sizes, which provides a similar API.\nThe main problem is that the user of our little crypto library has to decide on an appropriate cipher, mode, block size, and IV each time they want to encrypt or decrypt something.\nFor those of us that have a firm grasp of cryptography, this is fine, but for programmers who just want to encrypt some data without having to understand the relative strengths and weaknesses of block cipher modes, this is less than ideal.\nEvery argument we don&#39;t provide a sane default for is another chance for your API user to shoot themselves in the foot.</p>\n<p>Let&#39;s assume we&#39;re trying to make a top-level interface for a crypto library that other programmers will actually want to use.\nWith keyword arguments, we can make something like this:</p>\n<pre><code class=\"lang-cl\">(encrypt &quot;attack at dawn&quot; &quot;secret key&quot;)\n(encrypt &quot;attack at dawn&quot; &quot;secret key&quot; :cipher DES :block-size 256)\n(encrypt &quot;attack at dawn&quot; &quot;secret key&quot; :cipher AES :block-size 128 :mode ECB)\n</code></pre>\n<p>As you can see, this is significantly nicer than the fixed-argument version.\nMore verbose when you need to specify arguments, but that makes it easier to read, as well.\nThe important thing to note is that most of these arguments are optional. If we leave out the cipher argument, it will go to a sane default, like AES.\nThis allows the programmer to use as much, or as little, of the features of the function as they want, which reduces cognitive load,\nas well as providing a smooth learning curve; newer users can ignore the complexities such as the mode of operation until they understand what the options do.</p>\n<p>If this seems familiar, it&#39;s because this is the same pattern unix commands use.</p>\n","data":{"title":"Destructuring, Explained","date":"January 31st, 2018"},"excerpt":""}